(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["GLTS"] = factory();
	else
		root["GLTS"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./build/init.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./build/Camera/Perspective.js":
/*!*************************************!*\
  !*** ./build/Camera/Perspective.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar minMatrix_1 = __webpack_require__(/*! ../utils/minMatrix */ \"./build/utils/minMatrix.js\");\n\nvar PerspectiveCamera = /*#__PURE__*/function () {\n  function PerspectiveCamera(position, angle, aspect, near, far) {\n    _classCallCheck(this, PerspectiveCamera);\n\n    this.position = position;\n    this.angle = angle;\n    this.aspect = aspect;\n    this.near = near;\n    this.far = far;\n  }\n\n  _createClass(PerspectiveCamera, [{\n    key: \"update\",\n    value: function update() {\n      var m = new minMatrix_1[\"default\"]();\n      var vMatrix = m.init();\n      var pMatrix = m.init();\n      var tmpMatrix = m.init();\n      m.lookAt(this.position, [0, 0, 0], [0, 1, 0], vMatrix);\n      m.perspective(this.angle, this.aspect, this.near, this.far, pMatrix);\n      m.multiply(pMatrix, vMatrix, tmpMatrix);\n      return tmpMatrix;\n    }\n  }]);\n\n  return PerspectiveCamera;\n}();\n\nexports[\"default\"] = PerspectiveCamera;\n\n//# sourceURL=webpack://GLTS/./build/Camera/Perspective.js?");

/***/ }),

/***/ "./build/Core/Core.js":
/*!****************************!*\
  !*** ./build/Core/Core.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BufferManager = exports.ShaderManager = exports.ProgramManager = void 0;\n\nvar doxas_1 = __webpack_require__(/*! ./doxas */ \"./build/Core/doxas.js\");\n\nvar ProgramManager = /*#__PURE__*/function () {\n  function ProgramManager(gl) {\n    _classCallCheck(this, ProgramManager);\n\n    this.gl = gl;\n    this.wgld = new doxas_1.doxas(this.gl);\n  }\n\n  _createClass(ProgramManager, [{\n    key: \"init\",\n    value: function init(vs, fs) {\n      var v_shader = this.wgld.createShader(vs);\n      var f_shader = this.wgld.createShader(fs);\n      var program = this.wgld.createProgram(v_shader, f_shader);\n      return program;\n    }\n  }]);\n\n  return ProgramManager;\n}();\n\nexports.ProgramManager = ProgramManager;\n\nvar ShaderManager = /*#__PURE__*/function () {\n  function ShaderManager(gl) {\n    _classCallCheck(this, ShaderManager);\n\n    this.gl = gl;\n    this.setAttribute = new doxas_1.doxas(this.gl).setAttribute;\n  } // Attributeの配列を受け取って, Attributeの配列を返す\n\n\n  _createClass(ShaderManager, [{\n    key: \"addAttribute\",\n    value: function addAttribute(program, attList) {\n      var attributes = new Array();\n\n      for (var i = 0; i < attList.length; i++) {\n        var attribute = {\n          location: this.gl.getAttribLocation(program, attList[i].name),\n          stride: attList[i].stride\n        };\n        attributes.push(attribute);\n      }\n\n      return attributes;\n    }\n  }, {\n    key: \"addUniform\",\n    value: function addUniform(program, uniList) {\n      var uniforms = new Array();\n\n      for (var i = 0; i < uniList.length; i++) {\n        var uniform = {\n          location: this.gl.getUniformLocation(program, uniList[i].name),\n          data: uniList[i]\n        };\n        uniforms.push(uniform);\n      }\n\n      return uniforms;\n    }\n  }, {\n    key: \"setUniform\",\n    value: function setUniform(uniforms) {\n      for (var i = 0; i < uniforms.length; i++) {\n        switch (uniforms[i].data.type) {\n          case '1i':\n            this.gl.uniform1i(uniforms[i].location, uniforms[i].data.value);\n            break;\n\n          case 'm4fv':\n            this.gl.uniformMatrix4fv(uniforms[i].location, false, uniforms[i].data.value);\n            break;\n\n          case '3fv':\n            this.gl.uniform3fv(uniforms[i].location, uniforms[i].data.value);\n            break;\n\n          case '4fv':\n            this.gl.uniform4fv(uniforms[i].location, uniforms[i].data.value);\n            break;\n\n          default:\n            throw new Error(\"Uniform Error : This uniform type doesn't exist\");\n            break;\n        }\n      }\n    }\n  }]);\n\n  return ShaderManager;\n}();\n\nexports.ShaderManager = ShaderManager;\n\nvar BufferManager = /*#__PURE__*/function () {\n  function BufferManager(gl) {\n    _classCallCheck(this, BufferManager);\n\n    this.gl = gl;\n    this.wgld = new doxas_1.doxas(this.gl);\n    this.createIBO = this.wgld.createIBO;\n    this.createFramebuffer = this.wgld.createFramebuffer;\n  }\n\n  _createClass(BufferManager, [{\n    key: \"createVBO\",\n    value: function createVBO(data) {\n      var bufferList = new Array();\n\n      for (var i = 0; i < data.length; i++) {\n        bufferList.push(this.wgld.createVBO(data[i]));\n      }\n\n      return bufferList;\n    }\n  }, {\n    key: \"geometry\",\n    value: function geometry(data) {\n      var buffer = new Array();\n\n      for (var i = 0; i < data.length; i++) {\n        buffer.push({\n          vbo: new Array(),\n          ibo: new Array()\n        });\n        var list = [data[i].p, data[i].n, data[i].c];\n        var index = data[i].i;\n        var VBOs = this.createVBO(list);\n        buffer[i].vbo = VBOs;\n        var IBO = this.createIBO(index);\n        buffer[i].ibo = IBO;\n      }\n\n      return buffer;\n    }\n  }]);\n\n  return BufferManager;\n}();\n\nexports.BufferManager = BufferManager;\n\n//# sourceURL=webpack://GLTS/./build/Core/Core.js?");

/***/ }),

/***/ "./build/Core/doxas.js":
/*!*****************************!*\
  !*** ./build/Core/doxas.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.doxas = void 0;\n\nvar doxas = /*#__PURE__*/function () {\n  function doxas(gl) {\n    _classCallCheck(this, doxas);\n\n    this.gl = gl;\n  } // create vs & fs shader\n\n\n  _createClass(doxas, [{\n    key: \"createShader\",\n    value: function createShader(id) {\n      var shader;\n      var element = document.getElementById(id);\n\n      if (!element) {\n        throw new Error('Shader Error : There is no such element');\n      }\n\n      switch (element.type) {\n        case 'x-shader/x-vertex':\n          shader = this.gl.createShader(this.gl.VERTEX_SHADER);\n          break;\n\n        case 'x-shader/x-fragment':\n          shader = this.gl.createShader(this.gl.FRAGMENT_SHADER);\n          break;\n\n        default:\n          throw new Error('Shader Error : There is no vertex or fragment shader');\n      }\n\n      this.gl.shaderSource(shader, element.textContent);\n      this.gl.compileShader(shader); // check whether the shader has compiled successfully\n\n      if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {\n        throw new Error(\"Shader Error : Cannot complie the shader successfully\");\n      }\n\n      return shader;\n    } // create program\n\n  }, {\n    key: \"createProgram\",\n    value: function createProgram(vs, fs) {\n      var program = this.gl.createProgram();\n      this.gl.attachShader(program, vs);\n      this.gl.attachShader(program, fs);\n      this.gl.linkProgram(program); // check whether the program has linked successfully\n\n      if (this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {\n        this.gl.useProgram(program);\n        return program;\n      } else {\n        throw new Error('program error');\n      }\n    } // create vbo\n\n  }, {\n    key: \"createVBO\",\n    value: function createVBO(data) {\n      var vbo = this.gl.createBuffer();\n      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vbo);\n      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(data), this.gl.STATIC_DRAW);\n      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n      return vbo;\n    } // set attribute\n\n  }, {\n    key: \"setAttribute\",\n    value: function setAttribute(vbo, attributes) {\n      for (var i = 0; i < vbo.length; i++) {\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vbo[i]);\n        this.gl.enableVertexAttribArray(attributes[i].location);\n        this.gl.vertexAttribPointer(attributes[i].location, attributes[i].stride, this.gl.FLOAT, false, 0, 0);\n      }\n    } // create ibo\n\n  }, {\n    key: \"createIBO\",\n    value: function createIBO(data) {\n      var ibo = this.gl.createBuffer();\n      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, ibo);\n      this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Int16Array(data), this.gl.STATIC_DRAW);\n      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n      return ibo;\n    } // create texture\n\n  }, {\n    key: \"createTexture\",\n    value: function createTexture(source) {\n      var _this = this;\n\n      var img = new Image();\n      var tex = this.gl.createTexture();\n\n      img.onload = function () {\n        _this.gl.bindTexture(_this.gl.TEXTURE_2D, tex);\n\n        _this.gl.texImage2D(_this.gl.TEXTURE_2D, 0, _this.gl.RGBA, _this.gl.RGBA, _this.gl.UNSIGNED_BYTE, img);\n\n        _this.gl.generateMipmap(_this.gl.TEXTURE_2D);\n\n        _this.gl.texParameteri(_this.gl.TEXTURE_2D, _this.gl.TEXTURE_MIN_FILTER, _this.gl.LINEAR);\n\n        _this.gl.texParameteri(_this.gl.TEXTURE_2D, _this.gl.TEXTURE_MAG_FILTER, _this.gl.LINEAR);\n\n        _this.gl.texParameteri(_this.gl.TEXTURE_2D, _this.gl.TEXTURE_WRAP_S, _this.gl.REPEAT);\n\n        _this.gl.texParameteri(_this.gl.TEXTURE_2D, _this.gl.TEXTURE_WRAP_T, _this.gl.REPEAT);\n\n        _this.gl.bindTexture(_this.gl.TEXTURE_2D, null);\n      };\n\n      img.src = source;\n      return tex;\n    } // create cube texture\n\n  }, {\n    key: \"createCubeTexture\",\n    value: function createCubeTexture(source) {\n      var _this2 = this;\n\n      var cImg = new Array();\n      var tex = this.gl.createTexture();\n\n      var _loop = function _loop(i) {\n        var data = new Image();\n\n        data.onload = function () {\n          cImg.push(data);\n\n          if (i == 5) {\n            _this2.gl.bindTexture(_this2.gl.TEXTURE_CUBE_MAP, tex);\n\n            _this2.gl.texImage2D(_this2.gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, _this2.gl.RGBA, _this2.gl.RGBA, _this2.gl.UNSIGNED_BYTE, cImg[0]);\n\n            _this2.gl.texImage2D(_this2.gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, _this2.gl.RGBA, _this2.gl.RGBA, _this2.gl.UNSIGNED_BYTE, cImg[1]);\n\n            _this2.gl.texImage2D(_this2.gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, _this2.gl.RGBA, _this2.gl.RGBA, _this2.gl.UNSIGNED_BYTE, cImg[2]);\n\n            _this2.gl.texImage2D(_this2.gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, _this2.gl.RGBA, _this2.gl.RGBA, _this2.gl.UNSIGNED_BYTE, cImg[3]);\n\n            _this2.gl.texImage2D(_this2.gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, _this2.gl.RGBA, _this2.gl.RGBA, _this2.gl.UNSIGNED_BYTE, cImg[4]);\n\n            _this2.gl.texImage2D(_this2.gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, _this2.gl.RGBA, _this2.gl.RGBA, _this2.gl.UNSIGNED_BYTE, cImg[5]);\n\n            _this2.gl.generateMipmap(_this2.gl.TEXTURE_CUBE_MAP);\n\n            _this2.gl.texParameteri(_this2.gl.TEXTURE_CUBE_MAP, _this2.gl.TEXTURE_MIN_FILTER, _this2.gl.LINEAR);\n\n            _this2.gl.texParameteri(_this2.gl.TEXTURE_CUBE_MAP, _this2.gl.TEXTURE_MAG_FILTER, _this2.gl.LINEAR);\n\n            _this2.gl.texParameteri(_this2.gl.TEXTURE_CUBE_MAP, _this2.gl.TEXTURE_WRAP_S, _this2.gl.CLAMP_TO_EDGE);\n\n            _this2.gl.texParameteri(_this2.gl.TEXTURE_CUBE_MAP, _this2.gl.TEXTURE_WRAP_T, _this2.gl.CLAMP_TO_EDGE);\n\n            _this2.gl.bindTexture(_this2.gl.TEXTURE_CUBE_MAP, null);\n          }\n        };\n\n        data.src = source[i];\n      };\n\n      for (var i = 0; i < source.length; i++) {\n        _loop(i);\n      }\n\n      return tex;\n    } // create framebuffer\n\n  }, {\n    key: \"createFramebuffer\",\n    value: function createFramebuffer(width, height) {\n      var frameBuffer = this.gl.createFramebuffer();\n      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, frameBuffer);\n      var depthRenderBuffer = this.gl.createRenderbuffer();\n      this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, depthRenderBuffer);\n      this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_COMPONENT16, width, height);\n      this.gl.framebufferRenderbuffer(this.gl.FRAMEBUFFER, this.gl.DEPTH_ATTACHMENT, this.gl.RENDERBUFFER, depthRenderBuffer);\n      var fTexture = this.gl.createTexture();\n      this.gl.bindTexture(this.gl.TEXTURE_2D, fTexture);\n      this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, width, height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null);\n      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);\n      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);\n      this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, fTexture, 0);\n      this.gl.bindTexture(this.gl.TEXTURE_2D, null);\n      this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null);\n      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\n      return {\n        f: frameBuffer,\n        d: depthRenderBuffer,\n        t: fTexture\n      };\n    }\n  }]);\n\n  return doxas;\n}();\n\nexports.doxas = doxas;\n\n//# sourceURL=webpack://GLTS/./build/Core/doxas.js?");

/***/ }),

/***/ "./build/Geometry/Cube.js":
/*!********************************!*\
  !*** ./build/Geometry/Cube.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Color_1 = __webpack_require__(/*! ../utils/Color */ \"./build/utils/Color.js\");\n\nvar Geometry_1 = __webpack_require__(/*! ./Geometry */ \"./build/Geometry/Geometry.js\");\n\nvar Cube = /*#__PURE__*/function (_Geometry_1$default) {\n  _inherits(Cube, _Geometry_1$default);\n\n  var _super = _createSuper(Cube);\n\n  function Cube() {\n    _classCallCheck(this, Cube);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Cube, [{\n    key: \"init\",\n    value: function init(side, color) {\n      var hs = side * 0.5;\n      var pos = [-hs, -hs, hs, hs, -hs, hs, hs, hs, hs, -hs, hs, hs, -hs, -hs, -hs, -hs, hs, -hs, hs, hs, -hs, hs, -hs, -hs, -hs, hs, -hs, -hs, hs, hs, hs, hs, hs, hs, hs, -hs, -hs, -hs, -hs, hs, -hs, -hs, hs, -hs, hs, -hs, -hs, hs, hs, -hs, -hs, hs, hs, -hs, hs, hs, hs, hs, -hs, hs, -hs, -hs, -hs, -hs, -hs, hs, -hs, hs, hs, -hs, hs, -hs];\n      var nor = [-1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0];\n      var col = new Array();\n\n      for (var i = 0; i < pos.length / 3; i++) {\n        var tc = new Array();\n\n        if (color == 'hsva') {\n          tc = new Color_1[\"default\"]().hsva(360 / pos.length / 3 * i, 1, 1, 1);\n        } else if (color == 'texture') {\n          tc = [0, 0, 0, 1];\n        } else {\n          if (color.length != 4) {\n            throw new Error('Geometry Error : The size of the fourth argument must be 4');\n          }\n\n          tc = color;\n        }\n\n        col.push(tc[0], tc[1], tc[2], tc[3]);\n      }\n\n      var st = [0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0];\n      var idx = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];\n      return {\n        p: pos,\n        n: nor,\n        c: col,\n        t: st,\n        i: idx\n      };\n    }\n  }]);\n\n  return Cube;\n}(Geometry_1[\"default\"]);\n\nexports[\"default\"] = Cube;\n\n//# sourceURL=webpack://GLTS/./build/Geometry/Cube.js?");

/***/ }),

/***/ "./build/Geometry/Geometry.js":
/*!************************************!*\
  !*** ./build/Geometry/Geometry.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Geometry = /*#__PURE__*/function () {\n  function Geometry() {\n    _classCallCheck(this, Geometry);\n\n    this.mat = new Float32Array(16);\n  }\n\n  _createClass(Geometry, [{\n    key: \"clear\",\n    value: function clear() {\n      this.mat[0] = 1;\n      this.mat[1] = 0;\n      this.mat[2] = 0;\n      this.mat[3] = 0;\n      this.mat[4] = 0;\n      this.mat[5] = 1;\n      this.mat[6] = 0;\n      this.mat[7] = 0;\n      this.mat[8] = 0;\n      this.mat[9] = 0;\n      this.mat[10] = 1;\n      this.mat[11] = 0;\n      this.mat[12] = 0;\n      this.mat[13] = 0;\n      this.mat[14] = 0;\n      this.mat[15] = 1;\n      return this.mat;\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(vec) {\n      this.mat[0] = this.mat[0] * vec[0];\n      this.mat[1] = this.mat[1] * vec[0];\n      this.mat[2] = this.mat[2] * vec[0];\n      this.mat[3] = this.mat[3] * vec[0];\n      this.mat[4] = this.mat[4] * vec[1];\n      this.mat[5] = this.mat[5] * vec[1];\n      this.mat[6] = this.mat[6] * vec[1];\n      this.mat[7] = this.mat[7] * vec[1];\n      this.mat[8] = this.mat[8] * vec[2];\n      this.mat[9] = this.mat[9] * vec[2];\n      this.mat[10] = this.mat[10] * vec[2];\n      this.mat[11] = this.mat[11] * vec[2];\n      this.mat[12] = this.mat[12];\n      this.mat[13] = this.mat[13];\n      this.mat[14] = this.mat[14];\n      this.mat[15] = this.mat[15];\n      return this.mat;\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(vec) {\n      this.mat[0] = this.mat[0];\n      this.mat[1] = this.mat[1];\n      this.mat[2] = this.mat[2];\n      this.mat[3] = this.mat[3];\n      this.mat[4] = this.mat[4];\n      this.mat[5] = this.mat[5];\n      this.mat[6] = this.mat[6];\n      this.mat[7] = this.mat[7];\n      this.mat[8] = this.mat[8];\n      this.mat[9] = this.mat[9];\n      this.mat[10] = this.mat[10];\n      this.mat[11] = this.mat[11];\n      this.mat[12] = this.mat[0] * vec[0] + this.mat[4] * vec[1] + this.mat[8] * vec[2] + this.mat[12];\n      this.mat[13] = this.mat[1] * vec[0] + this.mat[5] * vec[1] + this.mat[9] * vec[2] + this.mat[13];\n      this.mat[14] = this.mat[2] * vec[0] + this.mat[6] * vec[1] + this.mat[10] * vec[2] + this.mat[14];\n      this.mat[15] = this.mat[3] * vec[0] + this.mat[7] * vec[1] + this.mat[11] * vec[2] + this.mat[15];\n      return this.mat;\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(angle, axis) {\n      var sq = Math.sqrt(axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]);\n\n      if (!sq) {\n        return null;\n      }\n\n      var a = axis[0],\n          b = axis[1],\n          c = axis[2];\n\n      if (sq != 1) {\n        sq = 1 / sq;\n        a *= sq;\n        b *= sq;\n        c *= sq;\n      }\n\n      var d = Math.sin(angle),\n          e = Math.cos(angle),\n          f = 1 - e,\n          g = this.mat[0],\n          h = this.mat[1],\n          i = this.mat[2],\n          j = this.mat[3],\n          k = this.mat[4],\n          l = this.mat[5],\n          m = this.mat[6],\n          n = this.mat[7],\n          o = this.mat[8],\n          p = this.mat[9],\n          q = this.mat[10],\n          r = this.mat[11],\n          s = a * a * f + e,\n          t = b * a * f + c * d,\n          u = c * a * f - b * d,\n          v = a * b * f - c * d,\n          w = b * b * f + e,\n          x = c * b * f + a * d,\n          y = a * c * f + b * d,\n          z = b * c * f - a * d,\n          A = c * c * f + e;\n      this.mat[0] = g * s + k * t + o * u;\n      this.mat[1] = h * s + l * t + p * u;\n      this.mat[2] = i * s + m * t + q * u;\n      this.mat[3] = j * s + n * t + r * u;\n      this.mat[4] = g * v + k * w + o * x;\n      this.mat[5] = h * v + l * w + p * x;\n      this.mat[6] = i * v + m * w + q * x;\n      this.mat[7] = j * v + n * w + r * x;\n      this.mat[8] = g * y + k * z + o * A;\n      this.mat[9] = h * y + l * z + p * A;\n      this.mat[10] = i * y + m * z + q * A;\n      this.mat[11] = j * y + n * z + r * A;\n      return this.mat;\n    }\n  }, {\n    key: \"transpose\",\n    value: function transpose() {\n      this.mat[0] = this.mat[0];\n      this.mat[1] = this.mat[4];\n      this.mat[2] = this.mat[8];\n      this.mat[3] = this.mat[12];\n      this.mat[4] = this.mat[1];\n      this.mat[5] = this.mat[5];\n      this.mat[6] = this.mat[9];\n      this.mat[7] = this.mat[13];\n      this.mat[8] = this.mat[2];\n      this.mat[9] = this.mat[6];\n      this.mat[10] = this.mat[10];\n      this.mat[11] = this.mat[14];\n      this.mat[12] = this.mat[3];\n      this.mat[13] = this.mat[7];\n      this.mat[14] = this.mat[11];\n      this.mat[15] = this.mat[15];\n      return this.mat;\n    }\n  }, {\n    key: \"inverse\",\n    value: function inverse() {\n      var a = this.mat[0],\n          b = this.mat[1],\n          c = this.mat[2],\n          d = this.mat[3],\n          e = this.mat[4],\n          f = this.mat[5],\n          g = this.mat[6],\n          h = this.mat[7],\n          i = this.mat[8],\n          j = this.mat[9],\n          k = this.mat[10],\n          l = this.mat[11],\n          m = this.mat[12],\n          n = this.mat[13],\n          o = this.mat[14],\n          p = this.mat[15],\n          q = a * f - b * e,\n          r = a * g - c * e,\n          s = a * h - d * e,\n          t = b * g - c * f,\n          u = b * h - d * f,\n          v = c * h - d * g,\n          w = i * n - j * m,\n          x = i * o - k * m,\n          y = i * p - l * m,\n          z = j * o - k * n,\n          A = j * p - l * n,\n          B = k * p - l * o,\n          ivd = 1 / (q * B - r * A + s * z + t * y - u * x + v * w);\n      this.mat[0] = (f * B - g * A + h * z) * ivd;\n      this.mat[1] = (-b * B + c * A - d * z) * ivd;\n      this.mat[2] = (n * v - o * u + p * t) * ivd;\n      this.mat[3] = (-j * v + k * u - l * t) * ivd;\n      this.mat[4] = (-e * B + g * y - h * x) * ivd;\n      this.mat[5] = (a * B - c * y + d * x) * ivd;\n      this.mat[6] = (-m * v + o * s - p * r) * ivd;\n      this.mat[7] = (i * v - k * s + l * r) * ivd;\n      this.mat[8] = (e * A - f * y + h * w) * ivd;\n      this.mat[9] = (-a * A + b * y - d * w) * ivd;\n      this.mat[10] = (m * u - n * s + p * q) * ivd;\n      this.mat[11] = (-i * u + j * s - l * q) * ivd;\n      this.mat[12] = (-e * z + f * x - g * w) * ivd;\n      this.mat[13] = (a * z - b * x + c * w) * ivd;\n      this.mat[14] = (-m * t + n * r - o * q) * ivd;\n      this.mat[15] = (i * t - j * r + k * q) * ivd;\n      return this.mat;\n    }\n  }]);\n\n  return Geometry;\n}();\n\nexports[\"default\"] = Geometry;\n\n//# sourceURL=webpack://GLTS/./build/Geometry/Geometry.js?");

/***/ }),

/***/ "./build/Geometry/Grid.js":
/*!********************************!*\
  !*** ./build/Geometry/Grid.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Color_1 = __webpack_require__(/*! ../utils/Color */ \"./build/utils/Color.js\");\n\nvar Geometry_1 = __webpack_require__(/*! ./Geometry */ \"./build/Geometry/Geometry.js\");\n\nvar Grid = /*#__PURE__*/function (_Geometry_1$default) {\n  _inherits(Grid, _Geometry_1$default);\n\n  var _super = _createSuper(Grid);\n\n  function Grid() {\n    _classCallCheck(this, Grid);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Grid, [{\n    key: \"init\",\n    value: function init(type, size, color) {\n      var pos = new Array();\n\n      switch (type) {\n        case 'XY':\n          pos = [-size, size, 0.0, size, size, 0.0, -size, -size, 0.0, size, -size, 0.0];\n          break;\n\n        case 'YZ':\n          pos = [0.0, -size, size, 0.0, size, size, 0.0, -size, -size, 0.0, size, -size];\n          break;\n\n        case 'ZX':\n          pos = [-size, 0.0, size, size, 0.0, size, -size, 0.0, -size, size, 0.0, -size];\n          break;\n\n        default:\n          break;\n      }\n\n      var nor = [0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0];\n      var col = new Array();\n\n      for (var i = 0; i < pos.length / 3; i++) {\n        var tc = new Array();\n\n        if (color == 'hsva') {\n          tc = new Color_1[\"default\"]().hsva(360 / pos.length / 3 * i, 1, 1, 1);\n        } else if (color == 'texture') {\n          tc = [0, 0, 0, 1];\n        } else {\n          if (color.length != 4) {\n            throw new Error('Geometry Error : The size of the fourth argument must be 4');\n          }\n\n          tc = color;\n        }\n\n        col.push(tc[0], tc[1], tc[2], tc[3]);\n      }\n\n      var st = [0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0];\n      var idx = [0, 1, 2, 3, 2, 1];\n      return {\n        p: pos,\n        n: nor,\n        c: col,\n        t: st,\n        i: idx\n      };\n    }\n  }]);\n\n  return Grid;\n}(Geometry_1[\"default\"]);\n\nexports[\"default\"] = Grid;\n\n//# sourceURL=webpack://GLTS/./build/Geometry/Grid.js?");

/***/ }),

/***/ "./build/Geometry/Sphere.js":
/*!**********************************!*\
  !*** ./build/Geometry/Sphere.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Color_1 = __webpack_require__(/*! ../utils/Color */ \"./build/utils/Color.js\");\n\nvar Geometry_1 = __webpack_require__(/*! ./Geometry */ \"./build/Geometry/Geometry.js\");\n\nvar Sphere = /*#__PURE__*/function (_Geometry_1$default) {\n  _inherits(Sphere, _Geometry_1$default);\n\n  var _super = _createSuper(Sphere);\n\n  function Sphere() {\n    _classCallCheck(this, Sphere);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Sphere, [{\n    key: \"init\",\n    value: function init(row, column, rad, color) {\n      var pos = new Array(),\n          nor = new Array(),\n          col = new Array(),\n          st = new Array(),\n          idx = new Array();\n\n      for (var i = 0; i <= row; i++) {\n        var r = Math.PI / row * i;\n        var ry = Math.cos(r);\n        var rr = Math.sin(r);\n\n        for (var ii = 0; ii <= column; ii++) {\n          var tr = Math.PI * 2 / column * ii;\n          var tx = rr * rad * Math.cos(tr);\n          var ty = ry * rad;\n          var tz = rr * rad * Math.sin(tr);\n          var rx = rr * Math.cos(tr);\n          var rz = rr * Math.sin(tr);\n          var tc = new Array();\n\n          if (color == 'hsva') {\n            tc = new Color_1[\"default\"]().hsva(360 / row * i, 1, 1, 1);\n          } else if (color == 'texture') {\n            tc = [0, 0, 0, 1];\n          } else {\n            if (color.length != 4) {\n              throw new Error('Geometry Error : The size of the fourth argument must be 4');\n            }\n\n            tc = color;\n          }\n\n          pos.push(tx, ty, tz);\n          nor.push(rx, ry, rz);\n          col.push(tc[0], tc[1], tc[2], tc[3]);\n          st.push(1 - 1 / column * ii, 1 / row * i);\n        }\n      }\n\n      var R = 0;\n\n      for (var _i = 0; _i < row; _i++) {\n        for (var _ii = 0; _ii < column; _ii++) {\n          R = (column + 1) * _i + _ii;\n          idx.push(R, R + 1, R + column + 2);\n          idx.push(R, R + column + 2, R + column + 1);\n        }\n      }\n\n      return {\n        p: pos,\n        n: nor,\n        c: col,\n        t: st,\n        i: idx\n      };\n    }\n  }]);\n\n  return Sphere;\n}(Geometry_1[\"default\"]);\n\nexports[\"default\"] = Sphere;\n\n//# sourceURL=webpack://GLTS/./build/Geometry/Sphere.js?");

/***/ }),

/***/ "./build/Geometry/Torus.js":
/*!*********************************!*\
  !*** ./build/Geometry/Torus.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Color_1 = __webpack_require__(/*! ../utils/Color */ \"./build/utils/Color.js\");\n\nvar Geometry_1 = __webpack_require__(/*! ./Geometry */ \"./build/Geometry/Geometry.js\");\n\nvar Torus = /*#__PURE__*/function (_Geometry_1$default) {\n  _inherits(Torus, _Geometry_1$default);\n\n  var _super = _createSuper(Torus);\n\n  function Torus() {\n    _classCallCheck(this, Torus);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Torus, [{\n    key: \"init\",\n    value: function init(row, column, irad, orad, color) {\n      var pos = new Array(),\n          nor = new Array(),\n          col = new Array(),\n          st = new Array(),\n          idx = new Array();\n\n      for (var i = 0; i <= row; i++) {\n        var r = Math.PI * 2 / row * i;\n        var rr = Math.cos(r);\n        var ry = Math.sin(r);\n\n        for (var ii = 0; ii <= column; ii++) {\n          var tr = Math.PI * 2 / column * ii;\n          var tx = (rr * irad + orad) * Math.cos(tr);\n          var ty = ry * irad;\n          var tz = (rr * irad + orad) * Math.sin(tr);\n          var rx = rr * Math.cos(tr);\n          var rz = rr * Math.sin(tr);\n          var tc = new Array();\n\n          if (color == 'hsva') {\n            tc = new Color_1[\"default\"]().hsva(360 / row * i, 1, 1, 1);\n          } else if (color == 'texture') {\n            tc = [0, 0, 0, 1];\n          } else {\n            if (color.length != 4) {\n              throw new Error('Geometry Error : The size of the fourth argument must be 4');\n            }\n\n            tc = color;\n          }\n\n          var rs = 1 / column * ii;\n          var rt = 1 / row * i + 0.5;\n\n          if (rt > 1.0) {\n            rt -= 1.0;\n          }\n\n          rt = 1.0 - rt;\n          pos.push(tx, ty, tz);\n          nor.push(rx, ry, rz);\n          col.push(tc[0], tc[1], tc[2], tc[3]);\n          st.push(rs, rt);\n        }\n      }\n\n      for (var _i = 0; _i < row; _i++) {\n        for (var _ii = 0; _ii < column; _ii++) {\n          var R = (column + 1) * _i + _ii;\n          idx.push(R, R + column + 1, R + 1);\n          idx.push(R + column + 1, R + column + 2, R + 1);\n        }\n      }\n\n      return {\n        p: pos,\n        n: nor,\n        c: col,\n        t: st,\n        i: idx\n      };\n    }\n  }]);\n\n  return Torus;\n}(Geometry_1[\"default\"]);\n\nexports[\"default\"] = Torus;\n\n//# sourceURL=webpack://GLTS/./build/Geometry/Torus.js?");

/***/ }),

/***/ "./build/Scene/Scene.js":
/*!******************************!*\
  !*** ./build/Scene/Scene.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar minMatrix_1 = __webpack_require__(/*! ../utils/minMatrix */ \"./build/utils/minMatrix.js\");\n\nvar Core_1 = __webpack_require__(/*! ../Core/Core */ \"./build/Core/Core.js\");\n\nvar Scene = /*#__PURE__*/function () {\n  function Scene(gl) {\n    _classCallCheck(this, Scene);\n\n    this.gl = gl;\n  }\n\n  _createClass(Scene, [{\n    key: \"init\",\n    value: function init(color, width, height) {\n      this.gl.clearColor(color[0], color[1], color[2], color[3]);\n      this.gl.clearDepth(1.0);\n      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);\n      this.gl.viewport(0, 0, width, height);\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(tmpMatrix, mvpMatrix, invMatrix, uniforms, mode, count, geometry) {\n      var m = new minMatrix_1[\"default\"]();\n      m.multiply(tmpMatrix, geometry.mat, mvpMatrix);\n      m.inverse(geometry.mat, invMatrix);\n      var manager = new Core_1.ShaderManager(this.gl);\n      manager.setUniform(uniforms);\n      this.gl.drawElements(mode, count, this.gl.UNSIGNED_SHORT, 0);\n    }\n  }]);\n\n  return Scene;\n}();\n\nexports[\"default\"] = Scene;\n\n//# sourceURL=webpack://GLTS/./build/Scene/Scene.js?");

/***/ }),

/***/ "./build/Texture/Texture.js":
/*!**********************************!*\
  !*** ./build/Texture/Texture.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar doxas_1 = __webpack_require__(/*! ../Core/doxas */ \"./build/Core/doxas.js\");\n\nvar TextureManager = /*#__PURE__*/function () {\n  function TextureManager(gl) {\n    _classCallCheck(this, TextureManager);\n\n    this.gl = gl;\n    this.wgld = new doxas_1.doxas(this.gl);\n    this.createCubeTexture = this.wgld.createCubeTexture;\n  }\n\n  _createClass(TextureManager, [{\n    key: \"createTexture\",\n    value: function createTexture(texture, source) {\n      this.gl.activeTexture(texture);\n      var tex = this.wgld.createTexture(source);\n      return tex;\n    }\n  }]);\n\n  return TextureManager;\n}();\n\nexports[\"default\"] = TextureManager;\n\n//# sourceURL=webpack://GLTS/./build/Texture/Texture.js?");

/***/ }),

/***/ "./build/init.js":
/*!***********************!*\
  !*** ./build/init.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Core_1 = __webpack_require__(/*! ./Core/Core */ \"./build/Core/Core.js\");\n\nvar Scene_1 = __webpack_require__(/*! ./Scene/Scene */ \"./build/Scene/Scene.js\");\n\nvar Perspective_1 = __webpack_require__(/*! ./Camera/Perspective */ \"./build/Camera/Perspective.js\");\n\nvar Texture_1 = __webpack_require__(/*! ./Texture/Texture */ \"./build/Texture/Texture.js\");\n\nvar Sphere_1 = __webpack_require__(/*! ./Geometry/Sphere */ \"./build/Geometry/Sphere.js\");\n\nvar Torus_1 = __webpack_require__(/*! ./Geometry/Torus */ \"./build/Geometry/Torus.js\");\n\nvar Cube_1 = __webpack_require__(/*! ./Geometry/Cube */ \"./build/Geometry/Cube.js\");\n\nvar Grid_1 = __webpack_require__(/*! ./Geometry/Grid */ \"./build/Geometry/Grid.js\");\n\nvar minMatrix_1 = __webpack_require__(/*! ./utils/minMatrix */ \"./build/utils/minMatrix.js\");\n\nvar doxas_1 = __webpack_require__(/*! ./Core/doxas */ \"./build/Core/doxas.js\");\n\nvar GLTS = function GLTS(gl) {\n  _classCallCheck(this, GLTS);\n\n  this.gl = gl;\n  this.glDoxas = new doxas_1.doxas(this.gl);\n  this.matIV = new minMatrix_1[\"default\"]();\n  this.ProgramManager = new Core_1.ProgramManager(this.gl);\n  this.ShaderManager = new Core_1.ShaderManager(this.gl);\n  this.BufferManager = new Core_1.BufferManager(this.gl);\n  this.Scene = new Scene_1[\"default\"](this.gl);\n  this.PerspectiveCamera = Perspective_1[\"default\"];\n  this.TextureManager = new Texture_1[\"default\"](this.gl);\n  this.Sphere = Sphere_1[\"default\"];\n  this.Torus = Torus_1[\"default\"];\n  this.Cube = Cube_1[\"default\"];\n  this.Grid = Grid_1[\"default\"];\n};\n\nexports[\"default\"] = GLTS;\n\n//# sourceURL=webpack://GLTS/./build/init.js?");

/***/ }),

/***/ "./build/utils/Color.js":
/*!******************************!*\
  !*** ./build/utils/Color.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Color = /*#__PURE__*/function () {\n  function Color() {\n    _classCallCheck(this, Color);\n  }\n\n  _createClass(Color, [{\n    key: \"hsva\",\n    value: function hsva(h, s, v, a) {\n      if (s > 1 || v > 1 || a > 1) {\n        return;\n      }\n\n      var th = h % 360;\n      var i = Math.floor(th / 60);\n      var f = th / 60 - i;\n      var m = v * (1 - s);\n      var n = v * (1 - s * f);\n      var k = v * (1 - s * (1 - f));\n      var color = new Array();\n\n      if (!(s > 0) && !(s < 0)) {\n        color.push(v, v, v, a);\n      } else {\n        var r = new Array(v, n, m, m, k, v);\n        var g = new Array(k, v, v, n, m, m);\n        var b = new Array(m, m, k, v, v, n);\n        color.push(r[i], g[i], b[i], a);\n      }\n\n      return color;\n    }\n  }]);\n\n  return Color;\n}();\n\nexports[\"default\"] = Color;\n\n//# sourceURL=webpack://GLTS/./build/utils/Color.js?");

/***/ }),

/***/ "./build/utils/minMatrix.js":
/*!**********************************!*\
  !*** ./build/utils/minMatrix.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar matIV = /*#__PURE__*/function () {\n  function matIV() {\n    _classCallCheck(this, matIV);\n\n    this.mat = this.create();\n  }\n\n  _createClass(matIV, [{\n    key: \"create\",\n    value: function create() {\n      return new Float32Array(16);\n    }\n  }, {\n    key: \"identity\",\n    value: function identity(dest) {\n      dest[0] = 1;\n      dest[1] = 0;\n      dest[2] = 0;\n      dest[3] = 0;\n      dest[4] = 0;\n      dest[5] = 1;\n      dest[6] = 0;\n      dest[7] = 0;\n      dest[8] = 0;\n      dest[9] = 0;\n      dest[10] = 1;\n      dest[11] = 0;\n      dest[12] = 0;\n      dest[13] = 0;\n      dest[14] = 0;\n      dest[15] = 1;\n      this.mat = dest;\n      return dest;\n    }\n  }, {\n    key: \"init\",\n    value: function init() {\n      return this.identity(this.create());\n    }\n  }, {\n    key: \"multiply\",\n    value: function multiply(mat1, mat2, dest) {\n      var a = mat1[0],\n          b = mat1[1],\n          c = mat1[2],\n          d = mat1[3],\n          e = mat1[4],\n          f = mat1[5],\n          g = mat1[6],\n          h = mat1[7],\n          i = mat1[8],\n          j = mat1[9],\n          k = mat1[10],\n          l = mat1[11],\n          m = mat1[12],\n          n = mat1[13],\n          o = mat1[14],\n          p = mat1[15],\n          A = mat2[0],\n          B = mat2[1],\n          C = mat2[2],\n          D = mat2[3],\n          E = mat2[4],\n          F = mat2[5],\n          G = mat2[6],\n          H = mat2[7],\n          I = mat2[8],\n          J = mat2[9],\n          K = mat2[10],\n          L = mat2[11],\n          M = mat2[12],\n          N = mat2[13],\n          O = mat2[14],\n          P = mat2[15];\n      dest[0] = A * a + B * e + C * i + D * m;\n      dest[1] = A * b + B * f + C * j + D * n;\n      dest[2] = A * c + B * g + C * k + D * o;\n      dest[3] = A * d + B * h + C * l + D * p;\n      dest[4] = E * a + F * e + G * i + H * m;\n      dest[5] = E * b + F * f + G * j + H * n;\n      dest[6] = E * c + F * g + G * k + H * o;\n      dest[7] = E * d + F * h + G * l + H * p;\n      dest[8] = I * a + J * e + K * i + L * m;\n      dest[9] = I * b + J * f + K * j + L * n;\n      dest[10] = I * c + J * g + K * k + L * o;\n      dest[11] = I * d + J * h + K * l + L * p;\n      dest[12] = M * a + N * e + O * i + P * m;\n      dest[13] = M * b + N * f + O * j + P * n;\n      dest[14] = M * c + N * g + O * k + P * o;\n      dest[15] = M * d + N * h + O * l + P * p;\n      return dest;\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(mat, vec, dest) {\n      dest[0] = mat[0] * vec[0];\n      dest[1] = mat[1] * vec[0];\n      dest[2] = mat[2] * vec[0];\n      dest[3] = mat[3] * vec[0];\n      dest[4] = mat[4] * vec[1];\n      dest[5] = mat[5] * vec[1];\n      dest[6] = mat[6] * vec[1];\n      dest[7] = mat[7] * vec[1];\n      dest[8] = mat[8] * vec[2];\n      dest[9] = mat[9] * vec[2];\n      dest[10] = mat[10] * vec[2];\n      dest[11] = mat[11] * vec[2];\n      dest[12] = mat[12];\n      dest[13] = mat[13];\n      dest[14] = mat[14];\n      dest[15] = mat[15];\n      return dest;\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(mat, vec, dest) {\n      dest[0] = mat[0];\n      dest[1] = mat[1];\n      dest[2] = mat[2];\n      dest[3] = mat[3];\n      dest[4] = mat[4];\n      dest[5] = mat[5];\n      dest[6] = mat[6];\n      dest[7] = mat[7];\n      dest[8] = mat[8];\n      dest[9] = mat[9];\n      dest[10] = mat[10];\n      dest[11] = mat[11];\n      dest[12] = mat[0] * vec[0] + mat[4] * vec[1] + mat[8] * vec[2] + mat[12];\n      dest[13] = mat[1] * vec[0] + mat[5] * vec[1] + mat[9] * vec[2] + mat[13];\n      dest[14] = mat[2] * vec[0] + mat[6] * vec[1] + mat[10] * vec[2] + mat[14];\n      dest[15] = mat[3] * vec[0] + mat[7] * vec[1] + mat[11] * vec[2] + mat[15];\n      return dest;\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(mat, angle, axis, dest) {\n      var sq = Math.sqrt(axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]);\n\n      if (!sq) {\n        return null;\n      }\n\n      var a = axis[0],\n          b = axis[1],\n          c = axis[2];\n\n      if (sq != 1) {\n        sq = 1 / sq;\n        a *= sq;\n        b *= sq;\n        c *= sq;\n      }\n\n      var d = Math.sin(angle),\n          e = Math.cos(angle),\n          f = 1 - e,\n          g = mat[0],\n          h = mat[1],\n          i = mat[2],\n          j = mat[3],\n          k = mat[4],\n          l = mat[5],\n          m = mat[6],\n          n = mat[7],\n          o = mat[8],\n          p = mat[9],\n          q = mat[10],\n          r = mat[11],\n          s = a * a * f + e,\n          t = b * a * f + c * d,\n          u = c * a * f - b * d,\n          v = a * b * f - c * d,\n          w = b * b * f + e,\n          x = c * b * f + a * d,\n          y = a * c * f + b * d,\n          z = b * c * f - a * d,\n          A = c * c * f + e;\n\n      if (angle) {\n        if (mat != dest) {\n          dest[12] = mat[12];\n          dest[13] = mat[13];\n          dest[14] = mat[14];\n          dest[15] = mat[15];\n        }\n      } else {\n        dest = mat;\n      }\n\n      dest[0] = g * s + k * t + o * u;\n      dest[1] = h * s + l * t + p * u;\n      dest[2] = i * s + m * t + q * u;\n      dest[3] = j * s + n * t + r * u;\n      dest[4] = g * v + k * w + o * x;\n      dest[5] = h * v + l * w + p * x;\n      dest[6] = i * v + m * w + q * x;\n      dest[7] = j * v + n * w + r * x;\n      dest[8] = g * y + k * z + o * A;\n      dest[9] = h * y + l * z + p * A;\n      dest[10] = i * y + m * z + q * A;\n      dest[11] = j * y + n * z + r * A;\n      return dest;\n    }\n  }, {\n    key: \"lookAt\",\n    value: function lookAt(eye, center, up, dest) {\n      var eyeX = eye[0],\n          eyeY = eye[1],\n          eyeZ = eye[2],\n          upX = up[0],\n          upY = up[1],\n          upZ = up[2],\n          centerX = center[0],\n          centerY = center[1],\n          centerZ = center[2];\n\n      if (eyeX == centerX && eyeY == centerY && eyeZ == centerZ) {\n        return this.identity(dest);\n      }\n\n      var x0, x1, x2, y0, y1, y2, z0, z1, z2, l;\n      z0 = eyeX - center[0];\n      z1 = eyeY - center[1];\n      z2 = eyeZ - center[2];\n      l = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);\n      z0 *= l;\n      z1 *= l;\n      z2 *= l;\n      x0 = upY * z2 - upZ * z1;\n      x1 = upZ * z0 - upX * z2;\n      x2 = upX * z1 - upY * z0;\n      l = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);\n\n      if (!l) {\n        x0 = 0;\n        x1 = 0;\n        x2 = 0;\n      } else {\n        l = 1 / l;\n        x0 *= l;\n        x1 *= l;\n        x2 *= l;\n      }\n\n      y0 = z1 * x2 - z2 * x1;\n      y1 = z2 * x0 - z0 * x2;\n      y2 = z0 * x1 - z1 * x0;\n      l = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);\n\n      if (!l) {\n        y0 = 0;\n        y1 = 0;\n        y2 = 0;\n      } else {\n        l = 1 / l;\n        y0 *= l;\n        y1 *= l;\n        y2 *= l;\n      }\n\n      dest[0] = x0;\n      dest[1] = y0;\n      dest[2] = z0;\n      dest[3] = 0;\n      dest[4] = x1;\n      dest[5] = y1;\n      dest[6] = z1;\n      dest[7] = 0;\n      dest[8] = x2;\n      dest[9] = y2;\n      dest[10] = z2;\n      dest[11] = 0;\n      dest[12] = -(x0 * eyeX + x1 * eyeY + x2 * eyeZ);\n      dest[13] = -(y0 * eyeX + y1 * eyeY + y2 * eyeZ);\n      dest[14] = -(z0 * eyeX + z1 * eyeY + z2 * eyeZ);\n      dest[15] = 1;\n      return dest;\n    }\n  }, {\n    key: \"perspective\",\n    value: function perspective(fov, aspect, near, far, dest) {\n      var t = near * Math.tan(fov * Math.PI / 360);\n      var r = t * aspect;\n      var a = r * 2,\n          b = t * 2,\n          c = far - near;\n      dest[0] = near * 2 / a;\n      dest[1] = 0;\n      dest[2] = 0;\n      dest[3] = 0;\n      dest[4] = 0;\n      dest[5] = near * 2 / b;\n      dest[6] = 0;\n      dest[7] = 0;\n      dest[8] = 0;\n      dest[9] = 0;\n      dest[10] = -(far + near) / c;\n      dest[11] = -1;\n      dest[12] = 0;\n      dest[13] = 0;\n      dest[14] = -(far * near * 2) / c;\n      dest[15] = 0;\n      return dest;\n    }\n  }, {\n    key: \"transpose\",\n    value: function transpose(mat, dest) {\n      dest[0] = mat[0];\n      dest[1] = mat[4];\n      dest[2] = mat[8];\n      dest[3] = mat[12];\n      dest[4] = mat[1];\n      dest[5] = mat[5];\n      dest[6] = mat[9];\n      dest[7] = mat[13];\n      dest[8] = mat[2];\n      dest[9] = mat[6];\n      dest[10] = mat[10];\n      dest[11] = mat[14];\n      dest[12] = mat[3];\n      dest[13] = mat[7];\n      dest[14] = mat[11];\n      dest[15] = mat[15];\n      return dest;\n    }\n  }, {\n    key: \"inverse\",\n    value: function inverse(mat, dest) {\n      var a = mat[0],\n          b = mat[1],\n          c = mat[2],\n          d = mat[3],\n          e = mat[4],\n          f = mat[5],\n          g = mat[6],\n          h = mat[7],\n          i = mat[8],\n          j = mat[9],\n          k = mat[10],\n          l = mat[11],\n          m = mat[12],\n          n = mat[13],\n          o = mat[14],\n          p = mat[15],\n          q = a * f - b * e,\n          r = a * g - c * e,\n          s = a * h - d * e,\n          t = b * g - c * f,\n          u = b * h - d * f,\n          v = c * h - d * g,\n          w = i * n - j * m,\n          x = i * o - k * m,\n          y = i * p - l * m,\n          z = j * o - k * n,\n          A = j * p - l * n,\n          B = k * p - l * o,\n          ivd = 1 / (q * B - r * A + s * z + t * y - u * x + v * w);\n      dest[0] = (f * B - g * A + h * z) * ivd;\n      dest[1] = (-b * B + c * A - d * z) * ivd;\n      dest[2] = (n * v - o * u + p * t) * ivd;\n      dest[3] = (-j * v + k * u - l * t) * ivd;\n      dest[4] = (-e * B + g * y - h * x) * ivd;\n      dest[5] = (a * B - c * y + d * x) * ivd;\n      dest[6] = (-m * v + o * s - p * r) * ivd;\n      dest[7] = (i * v - k * s + l * r) * ivd;\n      dest[8] = (e * A - f * y + h * w) * ivd;\n      dest[9] = (-a * A + b * y - d * w) * ivd;\n      dest[10] = (m * u - n * s + p * q) * ivd;\n      dest[11] = (-i * u + j * s - l * q) * ivd;\n      dest[12] = (-e * z + f * x - g * w) * ivd;\n      dest[13] = (a * z - b * x + c * w) * ivd;\n      dest[14] = (-m * t + n * r - o * q) * ivd;\n      dest[15] = (i * t - j * r + k * q) * ivd;\n      return dest;\n    }\n  }]);\n\n  return matIV;\n}();\n\nexports[\"default\"] = matIV;\n\n//# sourceURL=webpack://GLTS/./build/utils/minMatrix.js?");

/***/ })

/******/ })["default"];
});